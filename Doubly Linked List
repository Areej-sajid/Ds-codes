#include<iostream>
using namespace std;

template<typename T>
class node {
	T data;
	node<T>* next;
	node<T>* previous;
public:
	node(T val = T(), node<T>* ptr = nullptr, node<T>* ptr2 = nullptr) {
		data = val;
		next = ptr;
		previous = ptr2;
	}
	T retrieve()const { return data; };
	node<T>* nextnode()const { return next; };
	node<T>* previousnode()const { return previous; }
	template<typename U>
	friend class doubly_LL;
};

template<typename T>
class doubly_LL {
	node<T>* head;
	node<T>* tail;
public:
	doubly_LL() {
		head = tail = nullptr;
	}
	~doubly_LL() {
		
			while (!empty())
				pop_front();
	}
	//accessors
	node<T>* Head() const { return head; }
	bool empty() const {
			return head == nullptr;
	}
	T front() const {
			if (empty()) {
				cout << "List is empty";
				return 0;
			}
			return head->retrieve();
	}
	T end() const {
			if (empty()) {
				cout << "List is empty";
				return 0;
			}
			return tail->retrieve();
	}
	int size() const {
			int count = 0;
			for (node<T>* temp = head; temp != nullptr; temp = temp->next)
				count++;
			return count;
	}
	void push_front(T val) {
		node<T>* new_node = new node<T>(val, head, nullptr);
		//empty list
		if (head == nullptr) {
			head = tail = new_node;
		}
		// when one element para wa
		else {
			new_node->next = head;
			head->previous = new_node;
			head = new_node;
		}
	}
	void push_back(T val) {
		node<T>* new_node = new node<T>(val, nullptr, tail);
		if (head == nullptr) {
			head = tail = new_node;
		}
		else {
			new_node->previous = tail;
			tail->next = new_node;
			tail = new_node;
		}
	}
	void pop_front() {
		if (head == nullptr) {
			return;
		}
		else {
			node<T>* temp = head;
			head = head->next;
			if (head != nullptr) {
				head->previous = nullptr;
			}
			temp->next = nullptr;
			delete temp;
		}
	}
	void pop_end() {
		if (head == nullptr) {
			return;
		}
		else {
			node<T>* temp = tail;
			tail = tail->previous;
			if (tail != nullptr) {
				tail->next = nullptr;
			}
			temp->previous = nullptr;
			delete temp;
		}
		
	}
	void insert_middle(T val, int pos) {
		if (pos < 0) {
			cout << "Invalid position!" << endl;
			return;
		}
		else if (pos == 0) {
			push_front(val);
			return;
		}
		node<T>* temp = head;
		for (int i = 0; i < pos - 1 && temp != nullptr; i++) {
			temp = temp->next;
		}
		if (temp == nullptr) {
			cout << "Invalid position!" << endl;
			return;
		}
		if (temp == tail) {
			push_back(val);
			return;
		}
		node<T>* new_node = new node<T>(val);
		new_node->next = temp->next;
		new_node->previous = temp;
		temp->next->previous = new_node;
		temp->next = new_node;
	}
	
	void erase(int pos) {
		if (head == nullptr) {
			cout << "List is empty!" << endl;
			return;
		}
		if (pos == 1) {
			pop_front();
			return;
		}
		node<T>* temp = head;
		int count = 1;
		for (; temp != nullptr && count < pos; temp = temp->next, count++) {
		}
		if (temp == nullptr) {
			cout << "Invalid position!" << endl;
			return;
		}
		if (temp == tail) {
			pop_end();
			return;
		}
		temp->previous->next = temp->next;
		temp->next->previous = temp->previous;
		delete temp;
	}
	void display() const {
		for (node<T>* temp = head; temp != nullptr; temp = temp->next) {
			cout << temp->data << " ";
		}
		cout << endl;
	}
};
int main() {
	doubly_LL<int> dl;
	dl.push_front(3);
	dl.push_front(2);
	dl.display();
	dl.push_back(7);
	dl.push_back(10);
	dl.erase(2);
	dl.display();
	cout << "Front: " << dl.front() << endl;
	cout << "End: " << dl.end() << endl;
	dl.insert_middle(1,2);
	dl.display();
	dl.pop_front();
	dl.pop_end();
	dl.display();
	dl.erase(2);
	dl.display();
}
